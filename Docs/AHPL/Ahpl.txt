
╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                       ║
  ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎ ₍ᐢ⑅.ˬ.ᐢ₎ ₍ᐢ.ˬ.⑅ᐢ₎
║                                                                                                                       ║
║                                                    Estado Inicial                                                     ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 0. PC <= 0;                                                                                                             -- Se inicializa PC en 0
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                         Fetch                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 1. MAR <= PC;                                                                                                           -- Se carga la direccion del PC al MAR
    -> ( 2)

 2. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 1
    -> ( 3)

 3. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 2
    -> ( 4)

 4. MemoryAddress = MAR;
    Read = 1;                                                                                                            --Fetch ciclo 3
    IR <= Instruction;
    -> ( 5)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                        Decode                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 5. Pc <= Inc(Pc);                                                                                                       -- Posiciones del IR
    ->                                                                                                                   --[6.....0][14...12][30]
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 6) +             -- 0010111                   auipc
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 8) +             -- 0110111                   lui
(IR[6]  . IR[5]  . IR[4]’ . IR[3]  . IR[2]  . IR[1]  . IR[0]                                          X 9) +             -- 1101111                   jal
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          X 9) +             -- 1100111                   jalr
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’                     X15) +             -- 1100011    00C            beq/bne
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’                     X19) +             -- 1100011    10C            blt/bge
(IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]                      X21) +             -- 1100011    11C            bltu/bgeu
(IR[6]’ . IR[5]’ . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X23) +             -- 0000011    CCC            lb/lh/lw/lbu/lhu
(IR[6]’ . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X23) +             -- 0100011    CCC            sb/sh/sw
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           X38) +             -- 0010011    000            addi
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           X40) +             -- 0010011    010            slti
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            X44) +             -- 0010011    011            sltiu
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           X46) +             -- 0010011    100            xori
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           X47) +             -- 0010011    110            ori
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            X48) +             -- 0010011    111            andi
(IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            X49) +             -- 0010011    C01    C       slli/srli/srai
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]’ X53) +             -- 0110011    000    0       add
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]  X55) +             -- 0110011    000    1       sub
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            X58) +             -- 0110011    C01    C       sll/srl/sra
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           X60) +             -- 0110011    010            slt
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            X62) +             -- 0110011    011            sltu
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           X64) +             -- 0110011    100            xor
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           X65) +             -- 0110011    110            or
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            X66) +             -- 0110011    111            and
(IR[6]  . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          X67) +             -- 1110011    CCC            csrrw/csrrs/csrrc/csrrwi/csrrsi/csrrci
(IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           X74) +             -- 0110011    000            mul
(IR[1]  . IR[0]' . IR[15]  . IR[14] . IR[13]’                                                         X75) +             -- 110 10                    swsp (push)
(IR[1]  . IR[0]' . IR[15]' . IR[14] . IR[13]’)                                                        X79) +             -- 010 10                    lwsp (pop)
((IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          )' +
 (IR[6]  . IR[5]  . IR[4]’ . IR[3]  . IR[2]  . IR[1]  . IR[0]                                          )' +
 (IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]  . IR[1]  . IR[0]                                          )' +
 (IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’                     )' +
 (IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’                     )' +
 (IR[6]  . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]                      )' +
 (IR[6]’ . IR[5]’ . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          )' +
 (IR[6]’ . IR[5]  . IR[4]’ . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            )' +
 (IR[6]’ . IR[5]’ . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]’ )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’ . IR[30]  )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]            . IR[13]’ . IR[12]            )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]’           )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]  . IR[12]            )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]’ . IR[12]’           )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]’           )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]  . IR[13]  . IR[12]            )' +
 (IR[6]  . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]                                          )' +
 (IR[6]’ . IR[5]  . IR[4]  . IR[3]’ . IR[2]’ . IR[1]  . IR[0]  . IR[14]’ . IR[13]’ . IR[12]’           )) X84            -- Estado de exepcion de instruccion invalida

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                         AUIPC                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 6. Salida_ALU           = Suma(Pc,( IR(31:12), (12 T 0) ));                                                             -- Escribe en Registers direccion IR(11:7) la suma del PC con IR(31:12)
    -> ( 8)                                                                                                              -- desplazado 12 bits a la izquierda

 7. Registers[IR(11:7)] <= Suma(Pc,( IR(31:12), (12 T 0) ));                                                             -- Se repite la accion del estado 7, mientras la suma se efectua
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                          LUI                                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 8. Registers[IR(11:7)](31:12) <= IR(31:12);                                                                             -- Escribe en Registers direccion IR(11:7) el dato del IR(31:12)
    Registers[IR(11:7)](11: 0) <= '0';                                                                                   -- y rellena los 11 LSB con 0
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                       JAL/JALR                                                        ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

 9. Salida_ALU           = Suma(Pc,4);                                                                                   -- Escribe en Registers direccion IR(11:7) la suma del PC con 4
    -> (10)

10. Registers[IR(11:7)] <= Suma(Pc,4);                                                                                   -- Se repite la accion del estado 9 y se selecciona el siguiente estado
    -> (IR[3]  X11) +                                                                                                    -- 1 JAL
       (IR[3]’ X13)                                                                                                      -- 0 JALR

11. Salida_ALU = Suma(PC, sext( IR(31:12) ));                                                                            -- Escribe en PC la suma entre el PC actual y el valor de IR(12:31) al
    -> (12)                                                                                                              -- hacerle offset extendido en signo (una suerte de shift aritmetico)

12. PC        <= Suma(PC, sext( IR(31:12) ));                                                                            -- Se repite la accion del estado 11, mientras la suma se efectua
    -> ( 1)

13. Salida_ALU = Suma(Registers[IR(19:15)], sext(IR(31:12)) );                                                           -- Escribe en PC la suma entre Registers direccion IR(19:15) y el
    -> (14)                                                                                                              -- valor de IR(12:31) al hacerle offset extendido en signo

14. PC        <= Suma(Registers[IR(19:15)], sext(IR(31:12)) );                                                           -- Se repite la accion del estado 13, mientras la suma se efectua
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                INSTRUCCIONES DE SALTOS                                                ║
║                                                15. BEQ  /BNE                                                          ║
║                                                19. BLT  /BGE                                                          ║
║                                                21. BLTU /BGEU                                                         ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

15. Salida_ALU = Suma(Registers[IR(24:20)],Registers[IR(19:15)',1]);                                                     -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> (16)                                                                                                              -- direccion IR(14:19) pero no guarda el resultado

16. Salida_ALU = Suma(Registers[IR(24:20)],Registers[IR(19:15)',1]);                                                     -- Se repite la accion del estado 15, mientras la resta se efectua
    ->
(IR[12]'. ALU_Control[1]  X17) +                                                                                         -- Si se desea que sean iguales   , y son iguales    va al estado 17
(IR[12]'. ALU_Control[1]' X 1) +                                                                                         -- Si se desea que sean iguales   , y son diferentes va al estado  1
(IR[12] . ALU_Control[1]  X 1) +                                                                                         -- Si se desea que sean diferentes, y son iguales    va al estado  1
(IR[12] . ALU_Control[1]' X17)                                                                                           -- Si se desea que sean diferentes, y son diferentes va al estado 17

17. Salida_ALU = Suma(PC, ((20 T IR(12)) ,IR(31), IR(7), IR(30:25), IR(11:8)));                                          -- Se suma PC con un arreglo de valores del IR
    ->  (18)

18. PC        <= Suma(PC, ((20 T IR(12)) ,IR(31), IR(7), IR(30:25), IR(11:8)));                                          -- Se repite la accion del estado 17, mientras la suma se efectua
    -> ( 1)

19. Salida_ALU = Suma( Registers[IR(19:15)], Registers[IR(24:20)]', 1 );                                                 -- Se compara el valor de Registers direccion IR(24:20) con Registers
    -> (20)                                                                                                              -- direccion IR(14:19)La comparacion tiene en cuenta el complemento a2

20. Salida_ALU = Suma( Registers[IR(19:15)], Registers[IR(24:20)]', 1 );                                                 -- Se repite la accion del estado 19, mientras la comparacion se hace
    ->
(ALU_Control[2] . ALU_Control[1]’ . IR[12]’ X17) +                                                                       -- rs1<rs2 blt
(ALU_Control[2]’. ALU_Control[1]’ . IR[12]’ X 1) +                                                                       -- rs1>rs2 blt
(ALU_Control[2]’. ALU_Control[1]’ . IR[12]  X17) +                                                                       -- rs1>rs2 bge
(ALU_Control[2] . ALU_Control[1]’ . IR[12]  X 1) +                                                                       -- rs1<rs2 bge
(                 ALU_Control[1]  .         X 1) +                                                                       -- sr1=rs2 bge blt

21. Salida_ALU = Suma( Registers[ IR[19:15]], Registers[ IR[24:20]]', 1);                                                -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> (22)                                                                                                              -- direccion IR(14:19) pero no guarda el resultado

22. Salida_ALU = Suma( Registers[ IR[19:15]], Registers[ IR[24:20]]', 1);                                                -- Se repite la accion del estado 21, mientras la resta se efectua
    ->
(ALU_Control[3] . ALU_Control[1]’ . IR[12]’ X 1) +                                                                       -- rs1>rs2 bltu
(ALU_Control[3]’. ALU_Control[1]’ . IR[12]’ X17) +                                                                       -- rs1<rs2 bltu
(                 ALU_Control[1]            X 1) +                                                                       -- rs1=rs2 bltu bgeu
(ALU_Control[3] . ALU_Control[1]’ . IR[12]  X17) +                                                                       -- rs1>rs2 bgeu
(ALU_Control[3]’. ALU_Control[1]’ . IR[12]  X 1) +                                                                       -- rs1<rs2 bgeu

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                     PREPARACION DE LECTURA/ESCRITURA EN MEMORIA                                       ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

23. Salida_ALU = Suma(Registers[IR(19:15)],IR[31:20]);                                                                   -- Se suma Registers direccion IR(19:15) con IR(31:20)
    -> (24)

24. MAR       <= Suma(Registers[IR(19:15)],IR[31:20]);                                                                   -- Se repite la accion del estado 23, mientras la suma se efectua
    ->
(IR[5]’                   X25) +                                                                                         -- Se decodifica si se requiere leer     un dato
(IR[5] .IR[13]’ . IR[12]’ X32) +                                                                                         -- Se decodifica si se requiere escribir un dato de 1Byte
(IR[5] .IR[13]’ . IR[12]  X34) +                                                                                         -- Se decodifica si se requiere escribir un dato de 2Byte
(IR[5] .IR[13]  . IR[12]’ X36)                                                                                           -- Se decodifica si se requiere escribir un dato de 4Byte

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                          INSTRUCCIONES DE LECTURA EN MEMORIA                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

25. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 1)
    Read = 1;
    -> (26)

26. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 2)
    Read = 1;
    ->
(IR[14]’ . IR[13]’ . IR[12]’ X27) +                                                                                      -- 000 goto LB
(IR[14]’ . IR[13]’ . IR[12]  X28) +                                                                                      -- 001 goto LH
(IR[14]’ . IR[13]  . IR[12]’ X29) +                                                                                      -- 010 goto LW
(IR[14]  . IR[13]’ . IR[12]’ X30) +                                                                                      -- 100 goto LBU
(IR[14]  . IR[13]’ . IR[12]  X31)                                                                                        -- 101 goto LHU

27. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]( 7: 0) <= MemoryOut(7: 0);                                                                       -- Se guarda  el LSByte en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31: 8) <= MemoryOut(7);                                                                          -- Se extiende el signo del valor a guardar
    -> ( 1)

28. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)](15: 0) <= MemoryOut(15: 0);                                                                      -- Se guardan los 2 LSBytes en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31:16) <= MemoryOut(15);                                                                         -- Se extiende el signo del valor a guardar
    -> ( 1)

29.MemoryAddress = MAR;                                                                                                  -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]        <= MemoryOut;                                                                             -- Se guardan los 4 Bytes en Registers en la direccion IR(11:7)
    -> ( 1)

30. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]( 7: 0) <= MemoryOut(7:0);                                                                        -- Se guarda  el LSByte en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31: 8) <= '0' ;                                                                                  -- Se rellena el registro con ceros
    -> ( 1)

31. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)](15: 0) <= MemoryOut(15:0);                                                                       -- Se guardan los 2 LSBytes en Registers en la direccion IR(11:7)
    Registers[IR(11:7)](31:16) <= '0';                                                                                   -- Se rellena el registro con ceros
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                         INSTRUCCIONES DE ESCRITURA EN MEMORIA                                         ║
║                                         32. SB                                                                        ║
║                                         34. SH                                                                        ║
║                                         36. SW                                                                        ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
32. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn( 7: 0) = Registers[IR(24:20)]( 7: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 7
    MemoryIn(31: 8) = Registers[IR(24:20)](    7);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  7
    -> (33)

33. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn( 7: 0) = Registers[IR(24:20)]( 7: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 7
    MemoryIn(31: 8) = Registers[IR(24:20)](    7);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  7
    -> ( 1)

34. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn(15: 0) = Registers[IR(24:20)](15: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 15
    MemoryIn(31:16) = Registers[IR(24:20)](   15);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  15
    -> (35)

35. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn(15: 0) = Registers[IR(24:20)](15: 0);                                                                       -- Se envia los datos de Registers direccion IR(24:20) del 0 al 15
    MemoryIn(31:16) = Registers[IR(24:20)](   15);                                                                       -- Se envia el  dato  de Registers direccion IR(24:20) solo el  15    -> X 1.

36. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn = Registers[IR(24:20)];                                                                                     -- Se envia los datos de Registers direccion IR(24:20)
    -> (37)

37. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn = Registers[IR(24:20)];                                                                                     -- Se envia los datos de Registers direccion IR(24:20)
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                              Operaciones de datos en registros con datos inmediatos                                   ║
║                              38. ADDI                                                                                 ║
║                              40. SLTI                                                                                 ║
║                              44. SLTIU                                                                                ║
║                              46. XORI                                                                                 ║
║                              47. ORI                                                                                  ║
║                              48. ANDI                                                                                 ║
║                              49. SLLI /SRLI /SRAI                                                                     ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

38. Salida_ALU           = Suma( Registers[IR(11:7)],IR(31:20) );                                                        -- Suma Registers direccion IR(11:7) con los datos en IR(31:20)
    -> ( 36)                                                                                                             -- el resultado se guarda en Registers direccion IR(11:7)

39. Registers[IR(11:7)] <= Suma( Registers[IR(11:7)],IR(31:20) );                                                        -- Se repite la accion del estado 38, mientras la suma se efectua
    -> ( 1)

40. Salida_ALU = Suma( Registers[IR(19:15)], IR[31:20]', 1 );                                                            -- Compara el dato en Registers direccion IR(19:15) con el dato
    -> (41)                                                                                                              -- almacenado IR(31:20). Esta comparacion se hace en complemento a 2

41. Salida_ALU = Suma( Registers[IR(19:15)], IR[31:20]', 1 );                                                            -- Se repite la accion del estado 40, mientras la comparacion se hace
    ->
(ALU_Control[1]’. ALU_Control[2]’. X42) +                                                                                -- IR(31:20) > Registers direccion IR(19:15)GOTO 42
(ALU_Control[1]’. ALU_Control[2] . X43) +                                                                                -- IR(31:20) < Registers direccion IR(19:15)GOTO 43
(ALU_Control[1]                    X43)                                                                                  -- IR(31:20) = Registers direccion IR(19:15)GOTO 43

42. Registers[IR(11:7)] <= '00000000000000000000000000000001';                                                           -- Se guarda un 0x1 en Registers direccion IR(11:7)
    -> ( 1)

43. Registers[IR(11:7)] <='0';                                                                                           -- Se guarda un 0x0 en Registers direccion IR(11:7)
    -> ( 1)

44. Salida_ALU = Suma( Registers[IR(19:15)], IR[31:20]', 1 );                                                            -- Se resta el dato de Registers direccion IR(19:15) con el dato
    -> (45)                                                                                                              -- almacenado en IR(31:20)

45. Salida_ALU = Suma( Registers[IR(19:15)], IR[31:20]', 1 );                                                            -- Se repite la accion del estado 35, mientras la resta se efectua
    ->
(ALU_Control[1]’. ALU_Control[2] . X42) +                                                                                -- IR(31:20) > Registers direccion IR(19:15) GOTO 42
(ALU_Control[1]’. ALU_Control[2]’. X43) +                                                                                -- IR(31:20) < Registers direccion IR(19:15) GOTO 43
(ALU_Control[1]                    X43)                                                                                  -- IR(31:20) = Registers direccion IR(19:15) GOTO 43

46. Registers[IR(11:7)] <= XOR(Registers[IR(19:15)], IR[31:20]);                                                         -- Se hace el XOR entre Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- almacenado en IR(31:20)

47. Registers[IR(11:7)] <=  OR(Registers[IR(19:15)], IR[31:20]);                                                         -- Se hace el OR entre e Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- almacenado en IR(31:20)

48. Registers[IR(11:7)] <=  AND(Registers[IR(19:15)], IR[31:20]);                                                        -- Se hace el AND entre e Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- almacenado en IR(31:20)

49. Counter <= IR(25:20);                                                                                                -- Se carga al Counter el valor de IR(25:20)
    ->
(IR[30]'.IR[14]' X50) +                                                                                                  -- SLLI
(IR[30]'.IR[14]  X51) +                                                                                                  -- SRLI
(IR[31]          X52)                                                                                                    -- SRAI

50. LogicShiftLeft(IR(19:15));                                                                                           -- Se hace El corrimiento a izquierda 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X50) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59)                                                                                                    -- Se va al estado donde se guarda el resultado

51. LogicShiftRight(IR(19:15));                                                                                          -- Se hace El corrimiento a derecha 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X51) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59)                                                                                                    -- Se va al estado donde se guarda el resultado

52. ArithmeticShiftRight(IR(19:15));                                                                                     -- Se hace corriemiento aritmetico izquierda 1 vez del dato IR(19:15)
    Counter <= Inc(Counter);                                                                                             -- Se incrementa el conteo de corrimientos realizados
    ->
(CounterControl' X52) +                                                                                                  -- Se va a este mismo estado si el contador no ha llegado al maximo
(CounterControl  X59)                                                                                                    -- Se va al estado donde se guarda el resultado

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                            Operaciones de datos en registros con datos en registros                                   ║
║                            53. ADD                                                                                    ║
║                            55. SUB                                                                                    ║
║                            58. SLL  /SRL  /SRA                                                                        ║
║                            60. SLT                                                                                    ║
║                            62. SLTU                                                                                   ║
║                            64. XOR                                                                                    ║
║                            65. OR                                                                                     ║
║                            66. AND                                                                                    ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

53. Salida_ALU           = Suma (Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se suman los valores almacenados en Registers direcciones IR(19:15)
    -> (54)                                                                                                              -- e IR(24:20) y el resultado va a Registers direccion IR(11:7)

54. Registers[IR(11:7)] <= Suma (Registers[IR(19:15)], Registers[IR(24:20)]);                                            -- Se repite la accion del estado 56, mientras la suma se efectua
    -> ( 1)

55. Salida_ALU           = Suma (Registers[IR(19:15)], Registers[IR(24:20)]', 1 );                                       -- Se restan los valores almacenados en Registers direcciones IR(19:15)
    -> (56)                                                                                                              -- e IR(24:20) y el resultado va a Registers direccion IR(11:7)

56. Salida_ALU           = Suma (Registers[IR(19:15)], Registers[IR(24:20)]', 1 );                                       -- Se repite la accion del estado 58, mientras la resta se efectua
    -> (57)

57. Registers[IR(11:7)] <= Suma (Registers[IR(19:15)], Registers[IR(24:20)]', 1 );                                       -- Se repite la accion del estado 59, mientras la resta se efectua
    -> ( 1)

58. Counter <= Registers[IR(24:20)]                                                                                      -- Se carga al Counter el valor del Registers direccion IR(25:20)
    ->
(IR[14]’          X 50) +                                                                                                -- SLL
(IR[14] . IR[30]’ X 51) +                                                                                                -- SRL
(IR[14] . IR[30]’ X 52)                                                                                                  -- SRA

59. Registers[IR(11:7)] <= AluShiftRegister;                                                                             -- Se carga el valor del shift realizado al registro indicado
    -> ( 1)

60. Salida_ALU = Suma( Registers[IR(19:15)], Registers[ IR(24:20)]', 1 );                                                -- Se compara el valor de Registers direccion IR(24:20) con Registers
    -> (61)                                                                                                              -- direccion IR(19:15)La comparacion tiene en cuenta el complemento a2

61. Salida_ALU = Suma( Registers[IR(19:15)], Registers[ IR(24:20)]', 1 );                                                -- Se repite la accion del estado 19, mientras la comparacion se hace
    ->
(ALU_Control[1]’ . ALU_Control[2]’. X42) +                                                                               -- Registers dir IR(19:15) > Registers dir IR(24:20) GOTO 42
(ALU_Control[1]’ . ALU_Control[2] . X43) +                                                                               -- Registers dir IR(19:15) < Registers dir IR(24:20) GOTO 43
(ALU_Control[1]                     X43)                                                                                 -- Registers dir IR(19:15) = Registers dir IR(24:20) GOTO 43

62. Salida_ALU = Suma( Registers[IR(19:15)], Registers[ IR(24:20)]', 1 );                                                -- Se resta el valor de Registers direccion IR(24:20) con Registers
    -> (63)                                                                                                              -- direccion IR(14:19) pero no guarda el resultado

63. Salida_ALU = Suma( Registers[IR(19:15)], Registers[ IR(24:20)]', 1 );                                                -- Se repite la accion del estado 59, mientras la resta se efectua
    ->
(ALU_Control[1]’. ALU_Control[3] . X42) +                                                                                -- Registers dir IR(19:15) > Registers dir IR(24:20) GOTO 42
(ALU_Control[1]’. ALU_Control[2]’. X43) +                                                                                -- Registers dir IR(19:15) < Registers dir IR(24:20) GOTO 43
(ALU_Control[1]                    X43)                                                                                  -- Registers dir IR(19:15) = Registers dir IR(24:20) GOTO 43

64. Registers[IR(11:7)] <= XOR( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el XOR entre Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- en Registers direccion (24:20)

65. Registers[IR(11:7)] <= OR ( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el OR  entre Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- en Registers direccion (24:20)

66. Registers[IR(11:7)] <= AND( Registers[IR(19:15)], Registers[IR(24:20)] );                                            -- Se hace el AND entre Registers direccion IR(19:15) con el dato
    -> ( 1)                                                                                                              -- en Registers direccion (24:20)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                         Instrucciones de Control Status Register                                      ║
║                                         68. CSRRW                                                                     ║
║                                         69. CSRRS                                                                     ║
║                                         70. CSRRC                                                                     ║
║                                         71. CSRRWI                                                                    ║
║                                         72. CSRRSI                                                                    ║
║                                         73. CSRRCI                                                                    ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

67. Registers(IR[11:7]) <= CSR[IR(31:20)];                                                                               -- Se carga el dato de CSR direccion IR(31:20) a Registers
    ->                                                                                                                   -- direccion IR(11:7)
(IR[14]'. IR[13]'. IR[12]  X68) +                                                                                        --CSRRW
(IR[14]'. IR[13] . IR[12]' X69) +                                                                                        --CSRRS
(IR[14]'. IR[13] . IR[12]  X70) +                                                                                        --CSRRC
(IR[14] . IR[13]'. IR[12]  X71) +                                                                                        --CSRRWI
(IR[14] . IR[13] . IR[12]' X72) +                                                                                        --CSRRSI
(IR[14] . IR[13] . IR[12]  X73)                                                                                          --CSRRCI

68. CSR[IR(31:20)] <= Registers(IR[19:15]);                                                                              -- Se escribe en el CSR direccion IR(31:20) el dato de Registers
    -> ( 1)                                                                                                              -- direccion IR(19:15)

69. CSR[IR(31:20)] <= OR ( Registers[IR(11:7)],Registers[IR(19:15)] );                                                   -- Se escribe en el CSR direccion IR(31:20) el resultado del OR  entre
    -> ( 1)                                                                                                              -- Registers en las direcciones IR(11:7) e IR(19:15)

70. CSR[IR(31:20)] <= AND( Registers[IR(11:7)],Registers[IR(19:15)] );                                                   -- Se escribe en el CSR direccion IR(31:20) el resultado del AND entre
    -> ( 1)                                                                                                              -- Registers en las direcciones IR(11:7) e IR(19:15)

71. CSR[IR[31:20]] <= sext(IR[19:15]);                                                                                   -- El CSR direccion IR(31:20) toma el IR(19:15) con signo extendido
    -> ( 1)

72. CSR[IR(31:20)] <= OR ( Registers[IR(11:7)],IR(19:15) );                                                              -- Se escribe en el CSR direccion IR(31:20) el resultado del OR  entre
    -> ( 1)                                                                                                              -- Registers en la direccion IR(11:7) y el dato en IR(19:15)

73. CSR[IR(31:20)] <= AND( Registers[IR(11:7)],IR(19:15) );                                                              -- Se escribe en el CSR direccion IR(31:20) el resultado del AND entre
    -> ( 1)                                                                                                              -- Registers en la direccion IR(11:7) y el dato en IR(19:15)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                          MUL                                                          ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

74. Registers(IR[11:7]) <= Multiply( Registers(IR[19:15]),Registers(IR[24:20]) );                                        -- Se realiza la multiplicacion entre Registers direcciones IR(19:15)
    ->                                                                                                                   -- e IR(24:20)
(ALU_Control[0]' X81) +                                                                                                  -- La operacion aun no acaba, GOTO 81
(ALU_Control[0]  X 1)                                                                                                    -- La operacion ya termino

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                                                                                       ║
     (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)  (ฅ＾・ω・＾)ฅ ฅ(＾・ω・＾ฅ)
║                                                                                                                       ║
║                                                  FUNCIONES LOGICAS                                                    ║
║                                                                                                                       ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                       PUSH Y POP                                                      ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

75. Salida_ALU = Suma(Registers[0 τ 010],IR[12:7]);                                                                      -- PUSH: Se suma Registers direccion IR(12:7) con el SP, revisar direccionamiento
    -> (76)

76. MAR       <= Suma(Registers[0 τ 010],IR[12:7]);                                                                      -- Se repite la accion del estado 75, mientras la suma se efectua
    -> (77)

77. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn = Registers[IR(6:2)];                                                                                       -- Se envia el  dato  de Registers direccion IR(6:2) a memoria
    -> (78)

78. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn = Registers[IR(6:2)];                                                                                       -- Se envia el  dato  de Registers direccion IR(6:2) a memoria
    SP<=Inc(SP)                                                                                                          -- Incrementa el stack pointer
    -> ( 1)

79. Salida_ALU = Suma(Registers[0 τ 010],IR[12 , 6:2]);                                                                  --POP: Se suma Registers direccion IR(12| 6:2) con el SP, revisar direccoinamiento
    -> (80)

80. MAR       <= Suma(Registers[0 τ 010],IR[12 , 6:2]);                                                                  -- Se repite la accion del estado 79, mientras la suma se efectua
    -> (81)

81. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 1)
    Read = 1;
    -> (82)

82. MemoryAddress = MAR;                                                                                                 -- Se pide el dato de la direccion MAR a la memoria (Ciclo 2)
    Read = 1;
    -> (83)

83.MemoryAddress = MAR;                                                                                                  -- Se pide el dato de la direccion MAR a la memoria (Ciclo 3)
    Read = 1;
    Registers[IR(11:7)]        <= MemoryOut;                                                                             -- Se guardan los 4 Bytes en Registers en la direccion IR(11:7)
    SP<=Dec(SP)                                                                                                          -- Decrementa el stack pointer
    -> ( 1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                           Invalid instruction exception                                               ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

84. CSR[0x343] <= IR;                                                                                                    -- Se guarda la informacion de la instruccion invalida en MTVal
    -> (85)

85.  MAR <=Registers[0 τ 010];                                                                                           -- Se envia la informacion del SP al MAR
    -> (86)

86. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn = PC;                                                                                                       -- Se envia el  dato  del PC a memoria
    -> (87)

87. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn = PC;                                                                                                       -- Se envia el  dato  del PC a memoria
    SP <= Inc(SP)                                                                                                        -- Incrementa el stack pointer
    -> (88)

88. Pc <= CSR[0x341];                                                                                                    --
    -> (1)

╔═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                Interruption Cycle                                                     ║
╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

89. NULL
    ->
(CSR[768][4]'                                                                       X  1) +                            -- Si No estan habilitadas las interrupciones  se va al FETCH
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]' . IRQ[3]'                                X  1) +                            -- Si estan habilitadas las interrupciones pero no hay Request va al FETCH
(CSR[768][4] . IRQ[0]                                . CSR[772][28]'                X  1) +                            -- Si hay request del IRQ[0] pero esa interrupcion esta deshabilitada va al FETCH
(CSR[768][4] . IRQ[0]' . IRQ[1]                      . CSR[772][29]'                X  1) +                            -- Si hay request del IRQ[1] pero esa interrupcion esta deshabilitada va al FETCH
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]            . CSR[772][30]'                X  1) +                            -- Si hay request del IRQ[2] pero esa interrupcion esta deshabilitada va al FETCH
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]' . IRQ[3]  . CSR[772][31]'                X  1) +                            -- Si hay request del IRQ[3] pero esa interrupcion esta deshabilitada va al FETCH
(CSR[768][4] . IRQ[0]                                . CSR[772][28] . CSR[812][31]  X 90) +                            --  Si hay Request valido del IRQ[0:3] Pero se esta atendiendo otra
(CSR[768][4] . IRQ[0]' . IRQ[1]                      . CSR[772][29] . CSR[812][31]  X 91) +                            --  interrupcion, se va aun estado para dar a conocer que hay una
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]            . CSR[772][30] . CSR[812][31]  X 92) +                            --  interrupcion pendiente, cual es y luego se va al fetch
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]' . IRQ[3]  . CSR[772][31] . CSR[812][31]  X 93) +                            --
(CSR[768][4] . IRQ[0]                                . CSR[772][28] . CSR[812][31]' X 95) +
(CSR[768][4] . IRQ[0]' . IRQ[1]                      . CSR[772][29] . CSR[812][31]' X 95) +
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]            . CSR[772][30] . CSR[812][31]' X 95) +
(CSR[768][4] . IRQ[0]' . IRQ[1]' . IRQ[2]' . IRQ[3]  . CSR[772][31] . CSR[812][31]' X 95)

90. CSR[812][27] <= '1';
    -> (94)

91. CSR[812][28] <= '1';
    -> (94)

92. CSR[812][29] <= '1';
    -> (94)

93. CSR[812][30] <= '1';
    -> (94)

94. CSR[812][11] <= '1';
    -> ( 1)

95.  MAR <=Registers[0 τ 010];                                                                                           -- Se envia la informacion del SP al MAR -- PUSH PC
    -> (96)

96. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 1 de Write
    MemoryIn = PC;                                                                                                       -- Se envia el  dato  del PC a memoria
    -> (97)

97. MemoryAddress = MAR;                                                                                                 -- Se especifica la direccion en la que se va a escribir un dato
    Read = 0;                                                                                                            -- Ciclo 2 de Write
    MemoryIn = PC;                                                                                                       -- Se envia el  dato  del PC a memoria
    SP <= Inc(SP)                                                                                                        -- Incrementa el stack pointer
    ->
(IRQ[0]                                . CSR[772][28] X  98) +
(IRQ[0]' . IRQ[1]                      . CSR[772][29] X  99) +
(IRQ[0]' . IRQ[1]' . IRQ[2]            . CSR[772][30] X 100) +
(IRQ[0]' . IRQ[1]' . IRQ[2]' . IRQ[3]  . CSR[772][31] X 101)

98. Pc <= CSR(0x307);
    -> ( 1)

99. Pc <= CSR(0x308);
    -> ( 1)

100. Pc <= CSR(0x309);
     -> ( 1)

101. Pc <= CSR(0x310);
     -> ( 1)

TO DO
Cable entre SP y MAR (?? Bits)
Cable entre PC y MEMORIA (32 bits)
Cable entre IR y CSR (32 bits datos)
Cable entre CSR y Control (32 bits)
Cable de entrada IRQ y ACK (4 de IRQ 4 de ACK)
Cable de CSR a CONTROL de 6 bits (direcciones constantes)
Cable de CSR a PC (size -> PC)
